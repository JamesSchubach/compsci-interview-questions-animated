{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Util_1 = require(\"../Util\");\n\nvar Factory_1 = require(\"../Factory\");\n\nvar Node_1 = require(\"../Node\");\n\nvar Shape_1 = require(\"../Shape\");\n\nvar Rect_1 = require(\"./Rect\");\n\nvar Group_1 = require(\"../Group\");\n\nvar Global_1 = require(\"../Global\");\n\nvar Validators_1 = require(\"../Validators\");\n\nvar Global_2 = require(\"../Global\");\n\nvar EVENTS_NAME = 'tr-konva';\nvar ATTR_CHANGE_LIST = ['resizeEnabledChange', 'rotateAnchorOffsetChange', 'rotateEnabledChange', 'enabledAnchorsChange', 'anchorSizeChange', 'borderEnabledChange', 'borderStrokeChange', 'borderStrokeWidthChange', 'borderDashChange', 'anchorStrokeChange', 'anchorStrokeWidthChange', 'anchorFillChange', 'anchorCornerRadiusChange', 'ignoreStrokeChange'].map(function (e) {\n  return e + (\".\" + EVENTS_NAME);\n}).join(' ');\nvar NODES_RECT = 'nodesRect';\nvar TRANSFORM_CHANGE_STR = ['widthChange', 'heightChange', 'scaleXChange', 'scaleYChange', 'skewXChange', 'skewYChange', 'rotationChange', 'offsetXChange', 'offsetYChange', 'transformsEnabledChange', 'strokeWidthChange'].map(function (e) {\n  return e + (\".\" + EVENTS_NAME);\n}).join(' ');\nvar ANGLES = {\n  'top-left': -45,\n  'top-center': 0,\n  'top-right': 45,\n  'middle-right': -90,\n  'middle-left': 90,\n  'bottom-left': -135,\n  'bottom-center': 180,\n  'bottom-right': 135\n};\nvar TOUCH_DEVICE = ('ontouchstart' in Global_1.Konva._global);\n\nfunction getCursor(anchorName, rad) {\n  if (anchorName === 'rotater') {\n    return 'crosshair';\n  }\n\n  rad += Util_1.Util._degToRad(ANGLES[anchorName] || 0);\n  var angle = (Util_1.Util._radToDeg(rad) % 360 + 360) % 360;\n\n  if (Util_1.Util._inRange(angle, 315 + 22.5, 360) || Util_1.Util._inRange(angle, 0, 22.5)) {\n    return 'ns-resize';\n  } else if (Util_1.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {\n    return 'nesw-resize';\n  } else if (Util_1.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {\n    return 'ew-resize';\n  } else if (Util_1.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {\n    return 'nwse-resize';\n  } else if (Util_1.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {\n    return 'ns-resize';\n  } else if (Util_1.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {\n    return 'nesw-resize';\n  } else if (Util_1.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {\n    return 'ew-resize';\n  } else if (Util_1.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {\n    return 'nwse-resize';\n  } else {\n    Util_1.Util.error('Transformer has unknown angle for cursor detection: ' + angle);\n    return 'pointer';\n  }\n}\n\nvar ANCHORS_NAMES = ['top-left', 'top-center', 'top-right', 'middle-right', 'middle-left', 'bottom-left', 'bottom-center', 'bottom-right'];\nvar MAX_SAFE_INTEGER = 100000000;\n\nfunction getCenter(shape) {\n  return {\n    x: shape.x + shape.width / 2 * Math.cos(shape.rotation) + shape.height / 2 * Math.sin(-shape.rotation),\n    y: shape.y + shape.height / 2 * Math.cos(shape.rotation) + shape.width / 2 * Math.sin(shape.rotation)\n  };\n}\n\nfunction rotateAroundPoint(shape, angleRad, point) {\n  var x = point.x + (shape.x - point.x) * Math.cos(angleRad) - (shape.y - point.y) * Math.sin(angleRad);\n  var y = point.y + (shape.x - point.x) * Math.sin(angleRad) + (shape.y - point.y) * Math.cos(angleRad);\n  return __assign(__assign({}, shape), {\n    rotation: shape.rotation + angleRad,\n    x: x,\n    y: y\n  });\n}\n\nfunction rotateAroundCenter(shape, deltaRad) {\n  var center = getCenter(shape);\n  return rotateAroundPoint(shape, deltaRad, center);\n}\n\nfunction getSnap(snaps, newRotationRad, tol) {\n  var snapped = newRotationRad;\n\n  for (var i = 0; i < snaps.length; i++) {\n    var angle = Global_1.Konva.getAngle(snaps[i]);\n    var absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);\n    var dif = Math.min(absDiff, Math.PI * 2 - absDiff);\n\n    if (dif < tol) {\n      snapped = angle;\n    }\n  }\n\n  return snapped;\n}\n\nvar Transformer = function (_super) {\n  __extends(Transformer, _super);\n\n  function Transformer(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this._transforming = false;\n\n    _this._createElements();\n\n    _this._handleMouseMove = _this._handleMouseMove.bind(_this);\n    _this._handleMouseUp = _this._handleMouseUp.bind(_this);\n    _this.update = _this.update.bind(_this);\n\n    _this.on(ATTR_CHANGE_LIST, _this.update);\n\n    if (_this.getNode()) {\n      _this.update();\n    }\n\n    return _this;\n  }\n\n  Transformer.prototype.attachTo = function (node) {\n    this.setNode(node);\n    return this;\n  };\n\n  Transformer.prototype.setNode = function (node) {\n    Util_1.Util.warn('tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.');\n    return this.setNodes([node]);\n  };\n\n  Transformer.prototype.getNode = function () {\n    return this._nodes && this._nodes[0];\n  };\n\n  Transformer.prototype.setNodes = function (nodes) {\n    var _this = this;\n\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    if (this._nodes && this._nodes.length) {\n      this.detach();\n    }\n\n    this._nodes = nodes;\n\n    if (nodes.length === 1) {\n      this.rotation(nodes[0].rotation());\n    } else {\n      this.rotation(0);\n    }\n\n    this._nodes.forEach(function (node) {\n      var additionalEvents = node._attrsAffectingSize.map(function (prop) {\n        return prop + 'Change.' + EVENTS_NAME;\n      }).join(' ');\n\n      var onChange = function onChange() {\n        _this._resetTransformCache();\n\n        if (!_this._transforming) {\n          _this.update();\n        }\n      };\n\n      node.on(additionalEvents, onChange);\n      node.on(TRANSFORM_CHANGE_STR, onChange);\n      node.on(\"_clearTransformCache.\" + EVENTS_NAME, onChange);\n      node.on(\"xChange.\" + EVENTS_NAME + \" yChange.\" + EVENTS_NAME, onChange);\n\n      _this._proxyDrag(node);\n    });\n\n    this._resetTransformCache();\n\n    var elementsCreated = !!this.findOne('.top-left');\n\n    if (elementsCreated) {\n      this.update();\n    }\n\n    return this;\n  };\n\n  Transformer.prototype._proxyDrag = function (node) {\n    var _this = this;\n\n    var lastPos;\n    node.on(\"dragstart.\" + EVENTS_NAME, function (e) {\n      lastPos = node.getAbsolutePosition();\n\n      if (!_this.isDragging() && node !== _this.findOne('.back')) {\n        _this.startDrag();\n      }\n    });\n    node.on(\"dragmove.\" + EVENTS_NAME, function (e) {\n      if (!lastPos) {\n        return;\n      }\n\n      var abs = node.getAbsolutePosition();\n      var dx = abs.x - lastPos.x;\n      var dy = abs.y - lastPos.y;\n\n      _this.nodes().forEach(function (otherNode) {\n        if (otherNode === node) {\n          return;\n        }\n\n        if (otherNode.isDragging()) {\n          return;\n        }\n\n        var otherAbs = otherNode.getAbsolutePosition();\n        otherNode.setAbsolutePosition({\n          x: otherAbs.x + dx,\n          y: otherAbs.y + dy\n        });\n        otherNode.startDrag();\n      });\n\n      lastPos = null;\n    });\n  };\n\n  Transformer.prototype.getNodes = function () {\n    return this._nodes;\n  };\n\n  Transformer.prototype.getActiveAnchor = function () {\n    return this._movingAnchorName;\n  };\n\n  Transformer.prototype.detach = function () {\n    if (this._nodes) {\n      this._nodes.forEach(function (node) {\n        node.off('.' + EVENTS_NAME);\n      });\n    }\n\n    this._nodes = [];\n\n    this._resetTransformCache();\n  };\n\n  Transformer.prototype._resetTransformCache = function () {\n    this._clearCache(NODES_RECT);\n\n    this._clearCache('transform');\n\n    this._clearSelfAndDescendantCache('absoluteTransform');\n  };\n\n  Transformer.prototype._getNodeRect = function () {\n    return this._getCache(NODES_RECT, this.__getNodeRect);\n  };\n\n  Transformer.prototype.__getNodeShape = function (node, rot, relative) {\n    if (rot === void 0) {\n      rot = this.rotation();\n    }\n\n    var rect = node.getClientRect({\n      skipTransform: true,\n      skipShadow: true,\n      skipStroke: this.ignoreStroke()\n    });\n    var absScale = node.getAbsoluteScale(relative);\n    var absPos = node.getAbsolutePosition(relative);\n    var dx = rect.x * absScale.x - node.offsetX() * absScale.x;\n    var dy = rect.y * absScale.y - node.offsetY() * absScale.y;\n    var rotation = (Global_1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2);\n    var box = {\n      x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),\n      y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),\n      width: rect.width * absScale.x,\n      height: rect.height * absScale.y,\n      rotation: rotation\n    };\n    return rotateAroundPoint(box, -Global_1.Konva.getAngle(rot), {\n      x: 0,\n      y: 0\n    });\n  };\n\n  Transformer.prototype.__getNodeRect = function () {\n    var _this = this;\n\n    var node = this.getNode();\n\n    if (!node) {\n      return {\n        x: -MAX_SAFE_INTEGER,\n        y: -MAX_SAFE_INTEGER,\n        width: 0,\n        height: 0,\n        rotation: 0\n      };\n    }\n\n    var totalPoints = [];\n    this.nodes().map(function (node) {\n      var box = node.getClientRect({\n        skipTransform: true,\n        skipShadow: true,\n        skipStroke: _this.ignoreStroke()\n      });\n      var points = [{\n        x: box.x,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y + box.height\n      }, {\n        x: box.x,\n        y: box.y + box.height\n      }];\n      var trans = node.getAbsoluteTransform();\n      points.forEach(function (point) {\n        var transformed = trans.point(point);\n        totalPoints.push(transformed);\n      });\n    });\n    var tr = new Util_1.Transform();\n    tr.rotate(-Global_1.Konva.getAngle(this.rotation()));\n    var minX, minY, maxX, maxY;\n    totalPoints.forEach(function (point) {\n      var transformed = tr.point(point);\n\n      if (minX === undefined) {\n        minX = maxX = transformed.x;\n        minY = maxY = transformed.y;\n      }\n\n      minX = Math.min(minX, transformed.x);\n      minY = Math.min(minY, transformed.y);\n      maxX = Math.max(maxX, transformed.x);\n      maxY = Math.max(maxY, transformed.y);\n    });\n    tr.invert();\n    var p = tr.point({\n      x: minX,\n      y: minY\n    });\n    return {\n      x: p.x,\n      y: p.y,\n      width: maxX - minX,\n      height: maxY - minY,\n      rotation: Global_1.Konva.getAngle(this.rotation())\n    };\n  };\n\n  Transformer.prototype.getX = function () {\n    return this._getNodeRect().x;\n  };\n\n  Transformer.prototype.getY = function () {\n    return this._getNodeRect().y;\n  };\n\n  Transformer.prototype.getWidth = function () {\n    return this._getNodeRect().width;\n  };\n\n  Transformer.prototype.getHeight = function () {\n    return this._getNodeRect().height;\n  };\n\n  Transformer.prototype._createElements = function () {\n    this._createBack();\n\n    ANCHORS_NAMES.forEach(function (name) {\n      this._createAnchor(name);\n    }.bind(this));\n\n    this._createAnchor('rotater');\n  };\n\n  Transformer.prototype._createAnchor = function (name) {\n    var _this = this;\n\n    var anchor = new Rect_1.Rect({\n      stroke: 'rgb(0, 161, 255)',\n      fill: 'white',\n      strokeWidth: 1,\n      name: name + ' _anchor',\n      dragDistance: 0,\n      draggable: true,\n      hitStrokeWidth: TOUCH_DEVICE ? 10 : 'auto'\n    });\n    var self = this;\n    anchor.on('mousedown touchstart', function (e) {\n      self._handleMouseDown(e);\n    });\n    anchor.on('dragstart', function (e) {\n      anchor.stopDrag();\n      e.cancelBubble = true;\n    });\n    anchor.on('dragend', function (e) {\n      e.cancelBubble = true;\n    });\n    anchor.on('mouseenter', function () {\n      var rad = Global_1.Konva.getAngle(_this.rotation());\n      var cursor = getCursor(name, rad);\n      anchor.getStage().content.style.cursor = cursor;\n      _this._cursorChange = true;\n    });\n    anchor.on('mouseout', function () {\n      anchor.getStage().content.style.cursor = '';\n      _this._cursorChange = false;\n    });\n    this.add(anchor);\n  };\n\n  Transformer.prototype._createBack = function () {\n    var _this = this;\n\n    var back = new Shape_1.Shape({\n      name: 'back',\n      width: 0,\n      height: 0,\n      draggable: true,\n      sceneFunc: function sceneFunc(ctx) {\n        var tr = this.getParent();\n        var padding = tr.padding();\n        ctx.beginPath();\n        ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2);\n        ctx.moveTo(this.width() / 2, -padding);\n\n        if (tr.rotateEnabled()) {\n          ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util_1.Util._sign(this.height()) - padding);\n        }\n\n        ctx.fillStrokeShape(this);\n      },\n      hitFunc: function hitFunc(ctx, shape) {\n        if (!_this.shouldOverdrawWholeArea()) {\n          return;\n        }\n\n        var padding = _this.padding();\n\n        ctx.beginPath();\n        ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);\n        ctx.fillStrokeShape(shape);\n      }\n    });\n    this.add(back);\n\n    this._proxyDrag(back);\n  };\n\n  Transformer.prototype._handleMouseDown = function (e) {\n    this._movingAnchorName = e.target.name().split(' ')[0];\n\n    var attrs = this._getNodeRect();\n\n    var width = attrs.width;\n    var height = attrs.height;\n    var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n    this.sin = Math.abs(height / hypotenuse);\n    this.cos = Math.abs(width / hypotenuse);\n    window.addEventListener('mousemove', this._handleMouseMove);\n    window.addEventListener('touchmove', this._handleMouseMove);\n    window.addEventListener('mouseup', this._handleMouseUp, true);\n    window.addEventListener('touchend', this._handleMouseUp, true);\n    this._transforming = true;\n    var ap = e.target.getAbsolutePosition();\n    var pos = e.target.getStage().getPointerPosition();\n    this._anchorDragOffset = {\n      x: pos.x - ap.x,\n      y: pos.y - ap.y\n    };\n\n    this._fire('transformstart', {\n      evt: e,\n      target: this.getNode()\n    });\n\n    this.getNode()._fire('transformstart', {\n      evt: e,\n      target: this.getNode()\n    });\n  };\n\n  Transformer.prototype._handleMouseMove = function (e) {\n    var x, y, newHypotenuse;\n    var anchorNode = this.findOne('.' + this._movingAnchorName);\n    var stage = anchorNode.getStage();\n    stage.setPointersPositions(e);\n    var pp = stage.getPointerPosition();\n    var newNodePos = {\n      x: pp.x - this._anchorDragOffset.x,\n      y: pp.y - this._anchorDragOffset.y\n    };\n    var oldAbs = anchorNode.getAbsolutePosition();\n    anchorNode.setAbsolutePosition(newNodePos);\n    var newAbs = anchorNode.getAbsolutePosition();\n\n    if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {\n      return;\n    }\n\n    if (this._movingAnchorName === 'rotater') {\n      var attrs = this._getNodeRect();\n\n      x = anchorNode.x() - attrs.width / 2;\n      y = -anchorNode.y() + attrs.height / 2;\n      var delta = Math.atan2(-y, x) + Math.PI / 2;\n\n      if (attrs.height < 0) {\n        delta -= Math.PI;\n      }\n\n      var oldRotation = Global_1.Konva.getAngle(this.rotation());\n      var newRotation = oldRotation + delta;\n      var tol = Global_1.Konva.getAngle(this.rotationSnapTolerance());\n      var snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);\n      var diff = snappedRot - attrs.rotation;\n      var shape = rotateAroundCenter(attrs, diff);\n\n      this._fitNodesInto(shape, e);\n\n      return;\n    }\n\n    var keepProportion = this.keepRatio() || e.shiftKey;\n    var centeredScaling = this.centeredScaling() || e.altKey;\n\n    if (this._movingAnchorName === 'top-left') {\n      if (keepProportion) {\n        var comparePoint = centeredScaling ? {\n          x: this.width() / 2,\n          y: this.height() / 2\n        } : {\n          x: this.findOne('.bottom-right').x(),\n          y: this.findOne('.bottom-right').y()\n        };\n        newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));\n        var reverseX = this.findOne('.top-left').x() > comparePoint.x ? -1 : 1;\n        var reverseY = this.findOne('.top-left').y() > comparePoint.y ? -1 : 1;\n        x = newHypotenuse * this.cos * reverseX;\n        y = newHypotenuse * this.sin * reverseY;\n        this.findOne('.top-left').x(comparePoint.x - x);\n        this.findOne('.top-left').y(comparePoint.y - y);\n      }\n    } else if (this._movingAnchorName === 'top-center') {\n      this.findOne('.top-left').y(anchorNode.y());\n    } else if (this._movingAnchorName === 'top-right') {\n      if (keepProportion) {\n        var comparePoint = centeredScaling ? {\n          x: this.width() / 2,\n          y: this.height() / 2\n        } : {\n          x: this.findOne('.bottom-left').x(),\n          y: this.findOne('.bottom-left').y()\n        };\n        newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));\n        var reverseX = this.findOne('.top-right').x() < comparePoint.x ? -1 : 1;\n        var reverseY = this.findOne('.top-right').y() > comparePoint.y ? -1 : 1;\n        x = newHypotenuse * this.cos * reverseX;\n        y = newHypotenuse * this.sin * reverseY;\n        this.findOne('.top-right').x(comparePoint.x + x);\n        this.findOne('.top-right').y(comparePoint.y - y);\n      }\n\n      var pos = anchorNode.position();\n      this.findOne('.top-left').y(pos.y);\n      this.findOne('.bottom-right').x(pos.x);\n    } else if (this._movingAnchorName === 'middle-left') {\n      this.findOne('.top-left').x(anchorNode.x());\n    } else if (this._movingAnchorName === 'middle-right') {\n      this.findOne('.bottom-right').x(anchorNode.x());\n    } else if (this._movingAnchorName === 'bottom-left') {\n      if (keepProportion) {\n        var comparePoint = centeredScaling ? {\n          x: this.width() / 2,\n          y: this.height() / 2\n        } : {\n          x: this.findOne('.top-right').x(),\n          y: this.findOne('.top-right').y()\n        };\n        newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));\n        var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;\n        var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;\n        x = newHypotenuse * this.cos * reverseX;\n        y = newHypotenuse * this.sin * reverseY;\n        anchorNode.x(comparePoint.x - x);\n        anchorNode.y(comparePoint.y + y);\n      }\n\n      pos = anchorNode.position();\n      this.findOne('.top-left').x(pos.x);\n      this.findOne('.bottom-right').y(pos.y);\n    } else if (this._movingAnchorName === 'bottom-center') {\n      this.findOne('.bottom-right').y(anchorNode.y());\n    } else if (this._movingAnchorName === 'bottom-right') {\n      if (keepProportion) {\n        var comparePoint = centeredScaling ? {\n          x: this.width() / 2,\n          y: this.height() / 2\n        } : {\n          x: this.findOne('.top-left').x(),\n          y: this.findOne('.top-left').y()\n        };\n        newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));\n        var reverseX = this.findOne('.bottom-right').x() < comparePoint.x ? -1 : 1;\n        var reverseY = this.findOne('.bottom-right').y() < comparePoint.y ? -1 : 1;\n        x = newHypotenuse * this.cos * reverseX;\n        y = newHypotenuse * this.sin * reverseY;\n        this.findOne('.bottom-right').x(comparePoint.x + x);\n        this.findOne('.bottom-right').y(comparePoint.y + y);\n      }\n    } else {\n      console.error(new Error('Wrong position argument of selection resizer: ' + this._movingAnchorName));\n    }\n\n    var centeredScaling = this.centeredScaling() || e.altKey;\n\n    if (centeredScaling) {\n      var topLeft = this.findOne('.top-left');\n      var bottomRight = this.findOne('.bottom-right');\n      var topOffsetX = topLeft.x();\n      var topOffsetY = topLeft.y();\n      var bottomOffsetX = this.getWidth() - bottomRight.x();\n      var bottomOffsetY = this.getHeight() - bottomRight.y();\n      bottomRight.move({\n        x: -topOffsetX,\n        y: -topOffsetY\n      });\n      topLeft.move({\n        x: bottomOffsetX,\n        y: bottomOffsetY\n      });\n    }\n\n    var absPos = this.findOne('.top-left').getAbsolutePosition();\n    x = absPos.x;\n    y = absPos.y;\n    var width = this.findOne('.bottom-right').x() - this.findOne('.top-left').x();\n    var height = this.findOne('.bottom-right').y() - this.findOne('.top-left').y();\n\n    this._fitNodesInto({\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      rotation: Global_1.Konva.getAngle(this.rotation())\n    }, e);\n  };\n\n  Transformer.prototype._handleMouseUp = function (e) {\n    this._removeEvents(e);\n  };\n\n  Transformer.prototype.getAbsoluteTransform = function () {\n    return this.getTransform();\n  };\n\n  Transformer.prototype._removeEvents = function (e) {\n    if (this._transforming) {\n      this._transforming = false;\n      window.removeEventListener('mousemove', this._handleMouseMove);\n      window.removeEventListener('touchmove', this._handleMouseMove);\n      window.removeEventListener('mouseup', this._handleMouseUp, true);\n      window.removeEventListener('touchend', this._handleMouseUp, true);\n      var node = this.getNode();\n\n      this._fire('transformend', {\n        evt: e,\n        target: node\n      });\n\n      if (node) {\n        node.fire('transformend', {\n          evt: e,\n          target: node\n        });\n      }\n\n      this._movingAnchorName = null;\n    }\n  };\n\n  Transformer.prototype._fitNodesInto = function (newAttrs, evt) {\n    var _this = this;\n\n    var oldAttrs = this._getNodeRect();\n\n    var minSize = 1;\n\n    if (Util_1.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {\n      this.update();\n      return;\n    }\n\n    if (Util_1.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {\n      this.update();\n      return;\n    }\n\n    var allowNegativeScale = true;\n    var t = new Util_1.Transform();\n    t.rotate(Global_1.Konva.getAngle(this.rotation()));\n\n    if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf('left') >= 0) {\n      var offset = t.point({\n        x: -this.padding() * 2,\n        y: 0\n      });\n      newAttrs.x += offset.x;\n      newAttrs.y += offset.y;\n      newAttrs.width += this.padding() * 2;\n      this._movingAnchorName = this._movingAnchorName.replace('left', 'right');\n      this._anchorDragOffset.x -= offset.x;\n      this._anchorDragOffset.y -= offset.y;\n\n      if (!allowNegativeScale) {\n        this.update();\n        return;\n      }\n    } else if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf('right') >= 0) {\n      var offset = t.point({\n        x: this.padding() * 2,\n        y: 0\n      });\n      this._movingAnchorName = this._movingAnchorName.replace('right', 'left');\n      this._anchorDragOffset.x -= offset.x;\n      this._anchorDragOffset.y -= offset.y;\n      newAttrs.width += this.padding() * 2;\n\n      if (!allowNegativeScale) {\n        this.update();\n        return;\n      }\n    }\n\n    if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf('top') >= 0) {\n      var offset = t.point({\n        x: 0,\n        y: -this.padding() * 2\n      });\n      newAttrs.x += offset.x;\n      newAttrs.y += offset.y;\n      this._movingAnchorName = this._movingAnchorName.replace('top', 'bottom');\n      this._anchorDragOffset.x -= offset.x;\n      this._anchorDragOffset.y -= offset.y;\n      newAttrs.height += this.padding() * 2;\n\n      if (!allowNegativeScale) {\n        this.update();\n        return;\n      }\n    } else if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf('bottom') >= 0) {\n      var offset = t.point({\n        x: 0,\n        y: this.padding() * 2\n      });\n      this._movingAnchorName = this._movingAnchorName.replace('bottom', 'top');\n      this._anchorDragOffset.x -= offset.x;\n      this._anchorDragOffset.y -= offset.y;\n      newAttrs.height += this.padding() * 2;\n\n      if (!allowNegativeScale) {\n        this.update();\n        return;\n      }\n    }\n\n    if (this.boundBoxFunc()) {\n      var bounded = this.boundBoxFunc()(oldAttrs, newAttrs);\n\n      if (bounded) {\n        newAttrs = bounded;\n      } else {\n        Util_1.Util.warn('boundBoxFunc returned falsy. You should return new bound rect from it!');\n      }\n    }\n\n    var baseSize = 10000000;\n    var oldTr = new Util_1.Transform();\n    oldTr.translate(oldAttrs.x, oldAttrs.y);\n    oldTr.rotate(oldAttrs.rotation);\n    oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);\n    var newTr = new Util_1.Transform();\n    newTr.translate(newAttrs.x, newAttrs.y);\n    newTr.rotate(newAttrs.rotation);\n    newTr.scale(newAttrs.width / baseSize, newAttrs.height / baseSize);\n    var delta = newTr.multiply(oldTr.invert());\n\n    this._nodes.forEach(function (node) {\n      var parentTransform = node.getParent().getAbsoluteTransform();\n      var localTransform = node.getTransform().copy();\n      localTransform.translate(node.offsetX(), node.offsetY());\n      var newLocalTransform = new Util_1.Transform();\n      newLocalTransform.multiply(parentTransform.copy().invert()).multiply(delta).multiply(parentTransform).multiply(localTransform);\n      var attrs = newLocalTransform.decompose();\n      node.setAttrs(attrs);\n\n      _this._fire('transform', {\n        evt: evt,\n        target: node\n      });\n\n      node._fire('transform', {\n        evt: evt,\n        target: node\n      });\n    });\n\n    this.rotation(Util_1.Util._getRotation(newAttrs.rotation));\n\n    this._resetTransformCache();\n\n    this.update();\n    this.getLayer().batchDraw();\n  };\n\n  Transformer.prototype.forceUpdate = function () {\n    this._resetTransformCache();\n\n    this.update();\n  };\n\n  Transformer.prototype._batchChangeChild = function (selector, attrs) {\n    var anchor = this.findOne(selector);\n    anchor.setAttrs(attrs);\n  };\n\n  Transformer.prototype.update = function () {\n    var _this = this;\n\n    var attrs = this._getNodeRect();\n\n    this.rotation(Util_1.Util._getRotation(attrs.rotation));\n    var width = attrs.width;\n    var height = attrs.height;\n    var enabledAnchors = this.enabledAnchors();\n    var resizeEnabled = this.resizeEnabled();\n    var padding = this.padding();\n    var anchorSize = this.anchorSize();\n    this.find('._anchor').each(function (node) {\n      node.setAttrs({\n        width: anchorSize,\n        height: anchorSize,\n        offsetX: anchorSize / 2,\n        offsetY: anchorSize / 2,\n        stroke: _this.anchorStroke(),\n        strokeWidth: _this.anchorStrokeWidth(),\n        fill: _this.anchorFill(),\n        cornerRadius: _this.anchorCornerRadius()\n      });\n    });\n\n    this._batchChangeChild('.top-left', {\n      x: 0,\n      y: 0,\n      offsetX: anchorSize / 2 + padding,\n      offsetY: anchorSize / 2 + padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0\n    });\n\n    this._batchChangeChild('.top-center', {\n      x: width / 2,\n      y: 0,\n      offsetY: anchorSize / 2 + padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0\n    });\n\n    this._batchChangeChild('.top-right', {\n      x: width,\n      y: 0,\n      offsetX: anchorSize / 2 - padding,\n      offsetY: anchorSize / 2 + padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0\n    });\n\n    this._batchChangeChild('.middle-left', {\n      x: 0,\n      y: height / 2,\n      offsetX: anchorSize / 2 + padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0\n    });\n\n    this._batchChangeChild('.middle-right', {\n      x: width,\n      y: height / 2,\n      offsetX: anchorSize / 2 - padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0\n    });\n\n    this._batchChangeChild('.bottom-left', {\n      x: 0,\n      y: height,\n      offsetX: anchorSize / 2 + padding,\n      offsetY: anchorSize / 2 - padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0\n    });\n\n    this._batchChangeChild('.bottom-center', {\n      x: width / 2,\n      y: height,\n      offsetY: anchorSize / 2 - padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0\n    });\n\n    this._batchChangeChild('.bottom-right', {\n      x: width,\n      y: height,\n      offsetX: anchorSize / 2 - padding,\n      offsetY: anchorSize / 2 - padding,\n      visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0\n    });\n\n    this._batchChangeChild('.rotater', {\n      x: width / 2,\n      y: -this.rotateAnchorOffset() * Util_1.Util._sign(height) - padding,\n      visible: this.rotateEnabled()\n    });\n\n    this._batchChangeChild('.back', {\n      width: width,\n      height: height,\n      visible: this.borderEnabled(),\n      stroke: this.borderStroke(),\n      strokeWidth: this.borderStrokeWidth(),\n      dash: this.borderDash(),\n      x: 0,\n      y: 0\n    });\n  };\n\n  Transformer.prototype.isTransforming = function () {\n    return this._transforming;\n  };\n\n  Transformer.prototype.stopTransform = function () {\n    if (this._transforming) {\n      this._removeEvents();\n\n      var anchorNode = this.findOne('.' + this._movingAnchorName);\n\n      if (anchorNode) {\n        anchorNode.stopDrag();\n      }\n    }\n  };\n\n  Transformer.prototype.destroy = function () {\n    if (this.getStage() && this._cursorChange) {\n      this.getStage().content.style.cursor = '';\n    }\n\n    Group_1.Group.prototype.destroy.call(this);\n    this.detach();\n\n    this._removeEvents();\n\n    return this;\n  };\n\n  Transformer.prototype.toObject = function () {\n    return Node_1.Node.prototype.toObject.call(this);\n  };\n\n  return Transformer;\n}(Group_1.Group);\n\nexports.Transformer = Transformer;\n\nfunction validateAnchors(val) {\n  if (!(val instanceof Array)) {\n    Util_1.Util.warn('enabledAnchors value should be an array');\n  }\n\n  if (val instanceof Array) {\n    val.forEach(function (name) {\n      if (ANCHORS_NAMES.indexOf(name) === -1) {\n        Util_1.Util.warn('Unknown anchor name: ' + name + '. Available names are: ' + ANCHORS_NAMES.join(', '));\n      }\n    });\n  }\n\n  return val || [];\n}\n\nTransformer.prototype.className = 'Transformer';\n\nGlobal_2._registerNode(Transformer);\n\nFactory_1.Factory.addGetterSetter(Transformer, 'enabledAnchors', ANCHORS_NAMES, validateAnchors);\nFactory_1.Factory.addGetterSetter(Transformer, 'resizeEnabled', true);\nFactory_1.Factory.addGetterSetter(Transformer, 'anchorSize', 10, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'rotateEnabled', true);\nFactory_1.Factory.addGetterSetter(Transformer, 'rotationSnaps', []);\nFactory_1.Factory.addGetterSetter(Transformer, 'rotateAnchorOffset', 50, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'rotationSnapTolerance', 5, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'borderEnabled', true);\nFactory_1.Factory.addGetterSetter(Transformer, 'anchorStroke', 'rgb(0, 161, 255)');\nFactory_1.Factory.addGetterSetter(Transformer, 'anchorStrokeWidth', 1, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'anchorFill', 'white');\nFactory_1.Factory.addGetterSetter(Transformer, 'anchorCornerRadius', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'borderStroke', 'rgb(0, 161, 255)');\nFactory_1.Factory.addGetterSetter(Transformer, 'borderStrokeWidth', 1, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'borderDash');\nFactory_1.Factory.addGetterSetter(Transformer, 'keepRatio', true);\nFactory_1.Factory.addGetterSetter(Transformer, 'centeredScaling', false);\nFactory_1.Factory.addGetterSetter(Transformer, 'ignoreStroke', false);\nFactory_1.Factory.addGetterSetter(Transformer, 'padding', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(Transformer, 'node');\nFactory_1.Factory.addGetterSetter(Transformer, 'nodes');\nFactory_1.Factory.addGetterSetter(Transformer, 'boundBoxFunc');\nFactory_1.Factory.addGetterSetter(Transformer, 'shouldOverdrawWholeArea', false);\nFactory_1.Factory.backCompat(Transformer, {\n  lineEnabled: 'borderEnabled',\n  rotateHandlerOffset: 'rotateAnchorOffset',\n  enabledHandlers: 'enabledAnchors'\n});\nUtil_1.Collection.mapMethods(Transformer);","map":null,"metadata":{},"sourceType":"script"}